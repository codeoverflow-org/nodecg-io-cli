import * as semver from "semver";
import * as inquirer from "inquirer";
import * as path from "path";
import { directoryExists } from "../utils/fs";
import { ProductionInstallation } from "../utils/installation";
import { getServicesFromInstall } from "../install/prompt";
import { yellowInstallCommand } from "./utils";
import { NpmPackage } from "../utils/npm";
import { corePackage } from "../nodecgIOVersions";

/**
 * Describes all options for bundle generation a user has answered with inside the inquirer prompt
 */
export interface PromptedGenerationOptions {
    bundleName: string;
    bundleDir: string;
    description: string;
    version: semver.SemVer;
    services: string[];
    language: CodeLanguage;
    graphic: boolean;
    dashboard: boolean;
}

/**
 * Same as {@link PromptedGenerationOptions} but also includes computed fields that are generated by {@link computeGenOptsFields}.
 */
export interface GenerationOptions extends PromptedGenerationOptions {
    servicePackages: NpmPackage[];
    corePackage: NpmPackage;
    nodeeCGTypingsPackage: "nodecg" | "nodecg-types";
    bundlePath: string;
}

export type CodeLanguage = "typescript" | "javascript";

const kebabCaseRegex = /^([a-z][a-z0-9]*)(-[a-z0-9]+)*$/;

export async function promptGenerationOpts(
    nodecgDir: string,
    install: ProductionInstallation,
): Promise<GenerationOptions> {
    const defaultBundleDir = path.join(nodecgDir, "bundles");
    // if we are already in a bundle directory we use the name of the directory as a bundle name and the corresponding bundle dir
    const inBundleDir = path.dirname(process.cwd()) === defaultBundleDir;
    const bundleName = inBundleDir ? path.basename(process.cwd()) : undefined;
    const bundleDir = inBundleDir ? path.dirname(process.cwd()) : defaultBundleDir;

    const opts: PromptedGenerationOptions = await inquirer.prompt([
        {
            type: "input",
            name: "bundleName",
            message: "How should your new bundle be named?",
            default: bundleName,
            validate: validateBundleName,
        },
        {
            type: "input",
            name: "bundleDir",
            message: "In which bundle directory should your bundle be located?",
            default: bundleDir,
            validate: validateBundleDir,
        },
        {
            type: "input",
            name: "description",
            message: "Please give a bundle description:",
        },
        {
            type: "input",
            name: "version",
            message: "With which version number do you want to start?",
            default: "0.1.0",
            validate: validateVersion,
            filter: (ver) => new semver.SemVer(ver),
        },
        {
            type: "checkbox",
            name: "services",
            message: `Which services would you like to use? (they must be installed through ${yellowInstallCommand} first)`,
            choices: getServicesFromInstall(install, install.version),
            validate: validateServiceSelection,
        },
        {
            type: "list",
            name: "language",
            message: "Which programming language would you like to use?",
            choices: ["typescript", "javascript"],
        },
        {
            type: "confirm",
            name: "graphic",
            message: "Do you want to create a graphic?",
        },
        {
            type: "confirm",
            name: "dashboard",
            message: "Do you want to create a dashboard?",
        },
    ]);

    return computeGenOptsFields(opts, install);
}

// region prompt validation

function validateBundleName(str: string): true | string {
    if (str.length === 0) {
        return "You must provide a bundle name.";
    } else if (kebabCaseRegex.exec(str) === null) {
        return "Your bundle name should be in kebab case. E.g. my-nodecg-bundle-name.";
    } else {
        return true;
    }
}

async function validateBundleDir(dir: string): Promise<true | string> {
    if (await directoryExists(dir)) {
        return true;
    } else {
        return "The directory does not exist.";
    }
}

function validateVersion(ver: string): true | string {
    try {
        new semver.SemVer(ver);
        return true;
    } catch (_e) {
        return "Please enter a valid version number.";
    }
}

function validateServiceSelection(services: string[]): true | string {
    if (services.length === 0) {
        return "You should select at least one service to use.";
    } else {
        return true;
    }
}

// endregion

/**
 * Converts a {@link PromptedGenerationOptions} to a {@link GenerationOptions} by computing the fields
 * that {@link GenerationOptions} has using the passed installation.
 *
 * @param opts the prompted generation options
 * @param install the current nodecg-io installation. Used to get installed packages/exact versions.
 * @return opts including computed fields.
 */
export function computeGenOptsFields(
    opts: PromptedGenerationOptions,
    install: ProductionInstallation,
): GenerationOptions {
    const corePkg = install.packages.find((pkg) => pkg.name === corePackage);
    if (corePkg === undefined) {
        throw new Error("Core package in installation info could not be found.");
    }

    return {
        ...opts,
        corePackage: corePkg,
        servicePackages: opts.services.map((svc) => {
            const svcPackage = install.packages.find((pkg) => pkg.name.endsWith(svc));

            if (svcPackage === undefined) {
                throw new Error(`Service ${svc} has no corresponding package in the passed installation.`);
            }
            return svcPackage;
        }),
        bundlePath: path.join(opts.bundleDir, opts.bundleName),
        nodeeCGTypingsPackage: install.version === "0.1" ? "nodecg" : "nodecg-types",
    };
}
